package Parchis;

import java.awt.Point;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.ImageIcon;
import javax.swing.JLabel;

public class MainBoard extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     */
    public MainBoard() {
        initComponents();
        setLocationRelativeTo(null);
        initCustomComponents();
        // begin of test
//        inicioPrueba();
        // end of test
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new JPanelTableroParchis();
        jPanel2 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Parch√≠s");
        setBackground(new java.awt.Color(153, 255, 153));
        setForeground(java.awt.Color.orange);
        setMinimumSize(new java.awt.Dimension(10, 10));
        setResizable(false);
        setSize(new java.awt.Dimension(1, 1));
        addHierarchyBoundsListener(new java.awt.event.HierarchyBoundsListener() {
            public void ancestorMoved(java.awt.event.HierarchyEvent evt) {
            }
            public void ancestorResized(java.awt.event.HierarchyEvent evt) {
                formAncestorResized(evt);
            }
        });

        jPanel1.setDoubleBuffered(false);
        jPanel1.setFocusable(false);
        jPanel1.setMaximumSize(new java.awt.Dimension(600, 600));
        jPanel1.setMinimumSize(new java.awt.Dimension(600, 600));
        jPanel1.setOpaque(false);
        jPanel1.setPreferredSize(new java.awt.Dimension(600, 600));
        jPanel1.setLayout(null);

        jPanel2.setBackground(new java.awt.Color(51, 102, 255));
        jPanel2.setForeground(new java.awt.Color(204, 255, 0));
        jPanel2.setPreferredSize(new java.awt.Dimension(120, 600));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formAncestorResized(java.awt.event.HierarchyEvent evt) {//GEN-FIRST:event_formAncestorResized
        //Label1 resize TODO add your handling code here:
    }//GEN-LAST:event_formAncestorResized

    /**
     * @param args the command line arguments
     */
//    public static void main(String args[]) {
//        /* Set the Nimbus look and feel */
//        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
//        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
//         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
//         */
//        try {
//            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
//                if ("Nimbus".equals(info.getName())) {
//                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
//                    break;
//                }
//            }
//        } catch (ClassNotFoundException ex) {
//            java.util.logging.Logger.getLogger(MainBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (InstantiationException ex) {
//            java.util.logging.Logger.getLogger(MainBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (IllegalAccessException ex) {
//            java.util.logging.Logger.getLogger(MainBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
//            java.util.logging.Logger.getLogger(MainBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        }
//        //</editor-fold>
//        //</editor-fold>
//
//        /* Create and display the form */
//        java.awt.EventQueue.invokeLater(new Runnable() {
//            public void run() {
//                new MainBoard().setVisible(true);
//            }
//        });
//    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    // End of variables declaration//GEN-END:variables
    private javax.swing.JLabel[][] token = new JLabel[4][4];
    private final int tokenSize = 20;//Size of the tokens.
    private final int borderSize = 8;// Size of the border of the board
    private TokensSquares tokenSquare;//Number of the square/subsquare in which each token is.

    private void initCustomComponents() {
        tokenSquare = new TokensSquares();//All token are at their starting square.
        for (int player = 0; player < 4; player++) {
            for (int aToken = 0; aToken < 4; aToken++) {
                token[player][aToken] = new JLabel();
                token[player][aToken].setText("");
                token[player][aToken].setSize(tokenSize, tokenSize);
                Point pos;
                pos = calculatePosition(0, 0);
                pos = adjustPerPlayer(pos, 0, player);
                pos = adjustPerToken(pos, 0, aToken);
                pos = adustPerOffset(pos);
                token[player][aToken].setLocation(pos);
                setTokenIcon(player, aToken);
                jPanel1.add(token[player][aToken]);
//                showToken(player, aToken);
            }
        }
    }

//Sets the icon of each token.
    private void setTokenIcon(int player, int aToken) {
        ImageIcon yellowIcon = new javax.swing.ImageIcon(getClass().getResource("/Images/yellow_20px.png"));
        ImageIcon blueIcon = new javax.swing.ImageIcon(getClass().getResource("/Images/blue_20px.png"));
        ImageIcon redIcon = new javax.swing.ImageIcon(getClass().getResource("/Images/red_20px.png"));
        ImageIcon greenIcon = new javax.swing.ImageIcon(getClass().getResource("/Images/green_20px.png"));
        switch (player) {
            case 0://0->yellow
                token[player][aToken].setIcon(yellowIcon); // NOI18N
                break;
            case 1://1->green
                token[player][aToken].setIcon(greenIcon); // NOI18N
                break;
            case 2://2->red
                token[player][aToken].setIcon(redIcon); // NOI18N
                break;
            case 3://3->blue
                token[player][aToken].setIcon(blueIcon); // NOI18N
                break;
            default:
                throw new AssertionError();
        }

    }

//Sets the Location of a token and sets its visibility to TRUE.
    private void showToken(int player, int aToken) {
        Point pos;
        pos = calculateLocation(player, aToken);
        //token[player][aToken].setVisible(false);
        token[player][aToken].setLocation(pos);
        token[player][aToken].setVisible(true);
//        token[player][aToken].repaint();

        System.out.println("pos token(" + player + " " + aToken + ")=" + token[player][aToken].getLocation().x + " " + token[player][aToken].getLocation().y);
    }

//Reads square and subsquare of a token in order to calculate where to draw it.
    private Point calculateLocation(int player, int aToken) {
        Point pos;
        int square = tokenSquare.getSquare(player, aToken);
        if (square > 76) {// should be 0<=square<77
            square = square % 76;
        } else if (square < 0) {
            square = 0;
        }
        int subSquare = tokenSquare.getSubSquare(player, aToken);
        if (subSquare < 0) {// should be 0<=subSquare<3
            subSquare = -subSquare;
        }
        subSquare = subSquare % 3;

        pos = calculatePosition(square, subSquare);
        pos = adjustPerPlayer(pos, square, player);
        pos = adjustPerToken(pos, square, aToken);
        pos = adustPerOffset(pos);
        return pos;
    }

//Calculates que position (central coordinates) for a guiven square+subsquare.
    private Point calculatePosition(int square, int subSquare) {
        Point pos = new Point();
        int squareSub18 = ((square - 1) % 17) + 1;
        int dispX = 0, dispY = 0;
        if (square == 76) {
            dispX = 0;
            dispY = 35;
        } else if (square > 68) {
            dispX = 0 + 12 * (subSquare - 1);
            dispY = 300 - borderSize - 14 - 28 * (square - 68);
        } else if (squareSub18 == 0) {
            dispX = 195;
            dispY = 195;
        } else if (squareSub18 == 8) {
            dispX = 55 + 12 * (subSquare - 1);
            dispY = 300 - borderSize - 14 - 28 * (squareSub18 - 1);

        } else if (squareSub18 < 8) {
            dispX = 65 + 12 * (subSquare - 1);
            dispY = 300 - borderSize - 14 - 28 * (squareSub18 - 1);

        } else if (squareSub18 == 9) {
            dispX = 300 - borderSize - 14 - 28 * (16 - squareSub18);
            dispY = 55 + 12 * (subSquare - 1);
        } else if (squareSub18 < 17) {
            dispX = 300 - borderSize - 14 - 28 * (16 - squareSub18);
            dispY = 65 + 12 * (subSquare - 1);
        } else if (squareSub18 == 17) {
            dispX = 300 - borderSize - 14;
            dispY = 0 + 12 * (subSquare - 1);
        }
        pos.translate(dispX, dispY);
        pos = rotatePosition(pos, (4 - ((square - 1) / 17)) % 4);
        return pos;
    }

//Adjust coordinates depending of the player
    private Point adjustPerPlayer(Point pos1, int square, int player) {
        if (square == 76) {
            return rotatePosition(pos1, player);
        } else if (square == 0) {
            return rotatePosition(pos1, player);
        } else if ((square > 68) & (square < 76)) {
            return rotatePosition(pos1, player);
        }
        return pos1;
    }

//Adjust coordinates depending of the token
    private Point adjustPerToken(Point pos2, int square, int Token) {//Adjust the positions in starting and final squares 
        int dispX = 0, dispY = 0;
        if (square == 76) {//In final square
            pos2.translate(15 * ((Token - 2) % 2), 15 * ((1 - Token) % 2));
        } else if (square == 0) {//In starting square
            int disp2 = 45;
            dispX -= disp2 * ((2 - Token) % 2);//Each token
            dispY += disp2 * ((1 - Token) % 2);
        }
        pos2.translate(dispX, dispY);
        return pos2;
    }

//Calculates coordinates after a rotation (central coordinates)
    private Point rotatePosition(Point previousPoint, int nRotations) {//Rotates the position nRotation times clockwise
        int nRot = nRotations % 4;
        return new Point(
                previousPoint.x * ((1 - nRot) % 2) - previousPoint.y * ((2 - nRot) % 2),
                previousPoint.x * ((2 - nRot) % 2) + (previousPoint.y * ((1 - nRot) % 2))
        );
    }

//Adjusting coordinates for upper-left corner of the tokens and to canvas coordinates
    private Point adustPerOffset(Point pos) {
        pos.translate(300, 300);//Center of the board.
        pos.translate(-tokenSize / 2, -tokenSize / 2);//Correction for token size.
        return pos;
    }

    public boolean updateTokensPositions(TokensSquares newTokensSquare) {
        this.tokenSquare = newTokensSquare;
        for (int player = 0; player < 4; player++) {
            for (int aToken = 0; aToken < 4; aToken++) {
                showToken(player, aToken);
            }
        }
//        this.repaint();
        return true;
    }

    public void setTokenSquare(int player, int aToken) {
        token[player][aToken].setLocation(calculateLocation(player, aToken));
        System.out.println("pos token(" + player + " " + aToken + ")= sq" + tokenSquare.getSquare(player, aToken) + " ssq" + tokenSquare.getSubSquare(player, aToken) + " " + token[player][aToken].getLocation().x + " " + token[player][aToken].getLocation().y);

    }

    /*
    Anything below here is a test
    
    
     */
    private void inicioPrueba() {
        int velocidad = 500;
        Timer timer;
        TimerTask tarea;

        tarea = new TimerTask() {

            @Override
            public void run() {
                token[2][2].setLocation(1 + token[2][2].getLocation().x, 0);
                //jLabel1.setText(String.valueOf(jLabel1.getLocation().x));
            }
        };
        timer = new Timer();
        timer.scheduleAtFixedRate(tarea, velocidad, velocidad);

    }
}
